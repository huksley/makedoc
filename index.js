const os = require("os");
const fs = require("fs");
const path = require("path");
const marked = require("marked");
const R = require("ramda");
const jsdoc2md = require("jsdoc-to-markdown");

const capitalize = s => {
  if (typeof s !== "string") return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
};

const titleize = s => {
  return capitalize(s)
    .replace("-", " ")
    .replace("_", " ");
};

let params = {};
params.rootFolder = path.resolve(process.argv[2] || ".");

if (fs.existsSync(params.rootFolder + "/package.json")) {
  const folderPackage = JSON.parse(
    fs.readFileSync(params.rootFolder + "/package.json", { encoding: "utf-8" })
  );
  params = Object.assign(params, folderPackage.makedoc || {});
}

const defaultSpace = params.confluenceSpaceId || "Docs";
const gitBaseUrl = params.gitBaseUrl;
const fileBasePath = params.rootFolder || ".";
const ignoredMarkdownFiles = params.ignoredMarkdownFiles || [
  "PULL_REQUEST_TEMPLATE.md",
  "CODEOWNERS.md",
  "LICENSE.md"
];
const jsDocPaths = params.jsdoc || [];
const docTitle = params.title || titleize(path.basename(fileBasePath));
const outDir = path.resolve(params.outDir || "out");
const ignoredDirs = ["node_modules"];

/**
 * Consume file or folder recursively.
 *
 * @param {string} source - Starting path-like
 * @param {Function} consumer - Consumer for paths
 * @param {Function} acceptor - Optional acceptor to check before consuming paths, if true-like will pass to consumer.
 * @param {Function} dirAcceptor - Optional acceptor to check before consuming dirs, if true-like will continue recursively.
 */
function consumeFiles(source, consumer, acceptor, dirAcceptor, rootPath) {
  if (!fs.existsSync(source)) {
    throw new Error("Not found: " + source);
  }

  const stat = fs.lstatSync(source);
  if (
    stat.isDirectory() &&
    (dirAcceptor === undefined || dirAcceptor(source))
  ) {
    const files = fs.readdirSync(source);
    files.forEach(file => {
      const currentPath = path.join(source, file);
      if (fs.lstatSync(currentPath).isDirectory()) {
        consumeFiles(
          currentPath,
          consumer,
          acceptor,
          dirAcceptor,
          rootPath ? rootPath : source
        );
      } else if (acceptor === undefined || acceptor(currentPath)) {
        consumer(currentPath, rootPath);
      }
    });
  } else if (acceptor === undefined || acceptor(source)) {
    consumer(source, rootPath);
  }
}

function meaning(targetDir, file) {
  const content = fs.readFileSync(file, { encoding: "utf-8" });
  const tokens = marked.lexer(content, {});

  const defaultTitle = R.defaultTo({
    text:
      path.basename(file) === "README.md"
        ? titleize(path.basename(path.dirname(file)))
        : titleize(path.basename(file).replace(".md", ""))
  });

  // # Title or file-name
  const title = defaultTitle(
    R.head(tokens.filter(t => t.type === "heading" && t.depth === 1))
  ).text;

  const comments = tokens.filter(
    t => t.type === "html" && t.text.startsWith("<!--")
  );

  // Existing wiki space
  const wikiSpace = R.head(
    comments
      .filter(c => c.text.indexOf("Space:") >= 0)
      .map(c =>
        c.text
          .substring(c.text.indexOf(":") + 1)
          .replace("-->", "")
          .trim()
      )
  );

  // Existing wiki title
  const wikiTitle = R.head(
    comments
      .filter(c => c.text.indexOf("Title:") >= 0)
      .map(c =>
        c.text
          .substring(c.text.indexOf(":") + 1)
          .replace("-->", "")
          .trim()
      )
  );

  const wikiSkip = R.head(
    comments
      .filter(c => c.text.indexOf("Skip:") >= 0)
      .map(c =>
        c.text
          .substring(c.text.indexOf(":") + 1)
          .replace("-->", "")
          .trim()
      )
  );

  const meaning = {
    dir: targetDir,
    file: path.resolve(file).replace(fileBasePath + "/", ""),
    title,
    wikiSpace,
    wikiTitle,
    wikiSkip: wikiSkip === undefined ? false : wikiSkip === "true",
    content
  };

  return meaning;
}

function write(f) {
  const file = f.file;
  const absoluteFile = fileBasePath + "/" + file;
  const git = gitBaseUrl + file;
  const target = path.resolve(f.dir + "/" + file);

  let md = f.content;
  md = f.content.replace("# " + f.title + "\n", "\n");
  md =
    "\nAutogenerated from " +
    (git.endsWith("/README.md") ? git.replace("/README.md", "") : git) +
    "\n" +
    md;

  if (!f.wikiTitle) {
    md = "<!-- Title: " + f.title + " -->\n" + md;
  }

  // Check upper levels of hierarchy if there is readme and its deeper than root
  if (path.resolve(path.dirname(absoluteFile)) != fileBasePath) {
    let parentPath = path.resolve(path.dirname(path.dirname(absoluteFile)));
    while (parentPath != fileBasePath) {
      const parentReadme = path.resolve(parentPath, "README.md");
      if (fs.existsSync(parentReadme)) {
        console.info("Parent: " + parentReadme);
        // Get its title and add to md Parent:
        const tokens = marked.lexer(
          fs.readFileSync(parentReadme, { encoding: "utf-8" }),
          {}
        );
        const parentTitle = R.head(
          tokens.filter(t => t.type === "heading" && t.depth === 1)
        );
        if (parentTitle !== undefined) {
          md = "<!-- Parent: " + parentTitle.text + " -->\n" + md;
        }
      }
      parentPath = path.dirname(parentPath);
    }
  }

  if (f.parent) {
    md = "<!-- Parent: " + f.parent + " -->\n" + md;
  }

  if (!f.wikiSpace) {
    md = "<!-- Space: " + defaultSpace + " -->\n" + md;
  }

  if (f.jsdoc) {
    md = md + "\n\n" + f.jsdoc;
  }

  if (!f.wikiSkip) {
    fs.mkdirSync(path.dirname(target), { recursive: true });
    fs.writeFileSync(target, md);
  }
}

function produceJsdoc(dir, title) {
  return jsdoc2md
    .render({
      partial: __dirname + "/custom/main.hbs",
      helper: __dirname + "/custom/serverless-functions.js",
      files: fileBasePath + "/" + dir + "/**/*.js"
    })
    .then(markdown => ({
      dir,
      title,
      markdown
    }));
}

// FIXME: Ridiculous
xhtmlsafe = markdown => markdown.split("<hr>").join("<hr/>");

function parseMarkdown() {
  Promise.all(jsDocPaths.map(p => produceJsdoc(p.dir, p.title))).then(jsdoc => {
    const foundJsdoc = {};
    jsdoc.forEach(file => {
      foundJsdoc[file.dir] = file;
      console.info("Created jsdoc for " + file.dir);
    });

    consumeFiles(
      fileBasePath,
      (file, root) => {
        if (ignoredMarkdownFiles.indexOf(path.basename(file)) >= 0) {
          console.info("Ignoring markdown file: " + file);
        } else {
          const content = meaning(outDir, file);
          console.info(content.file);

          if (path.basename(content.file) == "README.md") {
            const jsdoc = foundJsdoc[path.dirname(content.file)];
            if (jsdoc !== undefined) {
              console.info("Using found jsdoc");
              jsdoc.used = true;
              content.jsdoc = xhtmlsafe(jsdoc.markdown);
            }
          }

          // Root file is a top of the tree
          if (file === "README.md") {
            content.title = docTitle;
            content.wikiTitle = docTitle;
            write(content);
          } else {
            write(R.assoc("parent", docTitle, content));
          }
        }
      },
      f => f.endsWith(".md"),
      d => ignoredDirs.indexOf(path.basename(d)) <= -1 && d != outDir
    );

    Object.keys(foundJsdoc).forEach(dir => {
      const jsdoc = foundJsdoc[dir];
      if (jsdoc.used === undefined) {
        console.info("Process standalone jsdoc", dir);
        const title =
          jsdoc.title !== undefined
            ? jsdoc.title
            : titleize(path.basename(dir));
        write({
          file: dir + "/README.md",
          dir: outDir,
          title,
          parent: docTitle,
          content: xhtmlsafe(jsdoc.markdown)
        });
      }
    });
  });
}

parseMarkdown();
